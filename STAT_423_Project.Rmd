---
title: "STAT 423 Project"
output: html_document
date: "2025-04-02"
---

```{r setup, include=FALSE}
install.packages("mosaic")
library("mosaic")
install.packages("ggplot2")
library(ggplot2)


install.packages("DescTools")
library(DescTools)

Skip_class <- read.csv("https://raw.githubusercontent.com/badongskii/stat423_skipping_class_survey/refs/heads/main/skippingclass_cleaned.csv")
attach(Skip_class)
Skip_class
names(Skip_class)

```
Applying modal imputation to fill non-responses
```{r}
#summary to show quick stats of each column in csv file. Reveals how many non responses in each.
summary(Skip_class)

```
Code to check which indices are n/a
```{r}
which(is.na(Skip_class$Percentage.Skip))
which(is.na(Skip_class$Types.Classes))
which(is.na(Skip_class$Options.Main))
which(is.na(Skip_class$Review.missed.material))
```
Missing data in Percentage.Skip, Types.Classes, Options.Main and Review.missed.material.
Find mean for each column which will be imputed later.
Note: decided to do mode since almost all questions are categorical.
```{r}
#mean.percentage.skip <- favstats(~Percentage.Skip, data = Skip_class)$mean
#mean.types.classes <- favstats(~Types.Classes, data = Skip_class)$mean
#mean.options.main <- favstats(~Options.Main, data = Skip_class)$mean
#mean.review.material <- favstats(~Review.missed.material, data = Skip_class)$mean

Skip_class.imputed <- Skip_class #copy of the data set

#Skip_class.imputed$Percentage.Skip[which(is.na(Skip_class$Percentage.Skip))] <- mean.percentage.skip
#Skip_class.imputed$Types.Classes[which(is.na(Skip_class$Types.Classes))] <- mean.types.classes
#Skip_class.imputed$Options.Main[which(is.na(Skip_class$Options.Main))] <- mean.options.main
#Skip_class.imputed$Review.missed.material[which(is.na(Review.missed.material))] <- mean.review.material

Mode(Skip_class$Percentage.Skip, na.rm = T)
mode.percentage.skip <- Mode(Skip_class$Percentage.Skip, na.rm = T)[[1]]
Skip_class.imputed$Percentage.Skip[which(is.na(Skip_class$Percentage.Skip))] <- mode.percentage.skip

Mode(Skip_class$Types.Classes, na.rm = T)
mode.type.classes <- Mode(Skip_class$Types.Classes, na.rm = T)[[1]]
Skip_class.imputed$Types.Classes[which(is.na(Skip_class$Types.Classes))] <- mode.type.classes

Mode(Skip_class$Options.Main, na.rm = T)
mode.options.main <- Mode(Skip_class$Options.Main, na.rm = T)[[1]]
Skip_class.imputed$Options.Main[which(is.na(Skip_class$Options.Main))] <- mode.options.main

Mode(Skip_class$Review.missed.material, na.rm = T)
mode.review.material <- Mode(Skip_class$Review.missed.material, na.rm = T)[[1]]
Skip_class.imputed$Review.missed.material[which(is.na(Review.missed.material))] <- mode.review.material

Skip_class.imputed
```


```{r}
summary(Skip_class.imputed)
```
Data is now cleaned.


#Compute a linear regression analyisis to determine our most important variables:
```{r}
skip_mod1 <- lm(`Percentage.Skip`~Gender+`Year.Study`+Courses+Reason+`Types.Classes`+`Options.Main`+`Review.missed.material`+`Grades.affected`+`Transport`+`Factor.not.to.skip`, data = Skip_class.imputed)
summary(skip_mod1)

```


## Get the mean values from the data collected:


```{r}
favstats(~Reason, data = Skip_class.imputed)
favstats(~Year.Study, data = Skip_class.imputed)
favstats(~Options.Main, data = Skip_class.imputed)
favstats(~Factor.not.to.skip, data = Skip_class.imputed)


```
$$
\begin{array}{lccc}
                           &  Mean   &  Sd    &  n       \\[0.5ex]
\hline
\text{Reason}    &   4.67     &   2.98      & 40                     \\[0.5ex]
\text{Year of Study}          &   2.5      &   1.13       &  40    &       \\[0.5ex]
\text{Options or Main Classes} &  1.27  & 0.452    & 40     \\[0.5ex]  
\text{Factor to not Skip Class}   &  2.7 & 1.02 & 40     \\[0.5ex]

\hline 
\end{array}
$$

## Including Plots


```{r}
hist(`Reason`,col="tomato2")
hist(`Year.Study`,col="gold2")
hist(`Options.Main`, col="lightskyblue")
hist(`Factor.not.to.skip`, col="lightcyan3")
```

Reason to not skip class proportion (Top 2)
```{r}
n <- 40
N <- 7400

most.combined <- sum(Skip_class.imputed$Factor.not.to.skip == 2) + 
                  sum(Skip_class.imputed$Factor.not.to.skip == 3)

prop.most.combined <- most.combined / n

#CI with 95% confidence
z <- qnorm(0.95)
most.combined.error <- sqrt((prop.most.combined*(1 - prop.most.combined)/(n - 1))*((N - n)/N))

most.combined.lb <- prop.most.combined - z * most.combined.error
most.combined.ub <- prop.most.combined + z * most.combined.error

cat("95% CI: [", most.combined.lb, ",", most.combined.ub, "]\n")
```
Conclusion: We can say with 95% confidence that between 53% and 78% of science students would choose not to skip class due to required attendance and lack of online material.


Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

#Mean and Confidence Intervals for Percentage Classes Skipped

n<-nrow(Skip_class)
#total amount of science undergraduates
N<-7400

#Sample mean
ybar<-mean(Skip_class.imputed$Percentage.Skip)

#Sample sd
s<- sd(Skip_class.imputed$Percentage.Skip)

z<-qnorm(0.975)

#Confidence interval
lowbo<-ybar-z*sqrt(1-(n/N))*(s/sqrt(n))
upbo<-ybar+z*sqrt(1-(n/N))*(s/sqrt(n))

ybar
c(lowbo, upbo)



# Define variables
y<-Skip_class.imputed$Percentage.Skip
x <- Skip_class.imputed$Year.Study

# Sample size and population size

# Sample means
xbar <- mean(x)

# Known population mean of x (Year of Study)
# If unknown, use xbar as estimate
xU <- 2.5  # Given or assumed known

# Regression coefficient (slope)
b1 <- sum((x - xbar) * (y - ybar)) / sum((x - xbar)^2)

# Regression estimate of population mean
yreg <- ybar + b1 * (xU - xbar)

# Standard error for regression estimator (with FPC)
residuals <- y - (b1 * x + (ybar - b1 * xbar))  # regression residuals
s2e <- sum(residuals^2) / (n - 2)
seyreg <- sqrt((1 - n/N) * (s2e / n))

# 95% Confidence Interval
z <- qnorm(0.975)
reglower <- yreg - z * seyreg
regupper <- yreg + z * seyreg

# Output results
yreg
c(reglower, regupper)

# Ratio estimate of yU
ybar <- mean(y)
xbar <- mean(x)
xU <- 2.5  # use known population mean if known, or sample mean
ratioestimate <- (ybar / xbar) * xU
